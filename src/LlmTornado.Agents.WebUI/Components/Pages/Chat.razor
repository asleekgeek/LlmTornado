@page "/"
@page "/chat"
@layout ChatLayout
@using Microsoft.AspNetCore.Components.Web
@using System.Text.Json
@using Models = LlmTornado.Chat.Web.Models
@inject ChatService ChatService
@inject IJSRuntime JSRuntime
@implements IDisposable
@rendermode InteractiveServer

<PageTitle>LlmTornado Chat</PageTitle>

<link href="css/chat.css" rel="stylesheet" />

<div class="chat-layout @(isDarkMode ? "dark-theme" : "light-theme")">
    <!-- Main Chat Area -->
    <div class="chat-main @(showLogPanel ? "with-log-panel" : "full-width")">
        <div class="chat-container">
            <ChatHeader IsConnected="isConnected" 
                       IsConnecting="isConnecting"
                       IsDarkMode="isDarkMode" 
                       ShowLogPanel="showLogPanel"
                       OnToggleTheme="ToggleTheme"
                       OnToggleLogPanel="ToggleLogPanel"
                       OnClearChat="ClearChat" />

            <ChatMessageList Messages="messages" 
                           ShowTypingIndicator="isConnecting" />

            <ChatInput CurrentMessage="currentMessage" 
                      CurrentMessageChanged="OnCurrentMessageChanged"
                      IsDisabled="isConnecting"
                      OnSendMessage="SendMessage" />
        </div>
    </div>

    <!-- Log Panel -->
    <LogPanel IsVisible="showLogPanel" 
             LogEvents="logEvents"
             OnClearLogs="ClearLogs"
             OnTogglePanel="ToggleLogPanel" />
</div>

@code {
    // State variables
    private List<Models.ChatMessage> messages = new();
    private List<Models.LogEvent> logEvents = new();
    private string currentMessage = "";
    private bool isConnecting = false;
    private bool isConnected = false;
    private bool showLogPanel = false;
    private bool isDarkMode = true;
    private string? runtimeId;
    private bool hasRendered = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            hasRendered = true;
            await LoadThemePreference();
            await CreateChatRuntime();
        }
    }

    #region Theme Management
    private async Task LoadThemePreference()
    {
        isDarkMode = await ChatService.LoadThemePreferenceAsync();
        StateHasChanged();
    }

    private async Task ToggleTheme()
    {
        isDarkMode = !isDarkMode;
        await ChatService.SaveThemePreferenceAsync(isDarkMode);
        StateHasChanged();
    }
    #endregion

    #region Runtime Management
    private async Task CreateChatRuntime()
    {
        try
        {
            var response = await ChatService.CreateChatRuntimeAsync();
            if (response != null)
            {
                runtimeId = response.RuntimeId;
                isConnected = !string.IsNullOrEmpty(runtimeId);

                if (isConnected)
                {
                    await AddSystemMessage($"Connected to runtime: {runtimeId}");
                    await AddLogEvent("Runtime", "Connected", $"Runtime ID: {runtimeId}", "");
                }
            }
        }
        catch (Exception ex)
        {
            await AddSystemMessage($"Failed to connect: {ex.Message}");
            await AddLogEvent("Runtime", "Connection Failed", ex.Message, "");
        }
    }
    #endregion

    #region Message Handling
    private async Task OnCurrentMessageChanged(string value)
    {
        currentMessage = value;
    }

    private async Task SendMessage(string message)
    {
        if (string.IsNullOrWhiteSpace(message) || isConnecting || string.IsNullOrEmpty(runtimeId))
            return;

        currentMessage = "";
        await AddUserMessage(message);
        await AddLogEvent("Message", "User Input", $"Message sent: {message.Length} characters", "");
        
        isConnecting = true;
        StateHasChanged();

        try
        {
            await StreamMessage(message);
        }
        catch (Exception ex)
        {
            await AddSystemMessage($"Error: {ex.Message}");
            await AddLogEvent("Error", "Stream Error", ex.Message, "");
        }
        finally
        {
            isConnecting = false;
            StateHasChanged();
        }
    }

    private async Task StreamMessage(string message)
    {
        var assistantMessage = new Models.ChatMessage
        {
            Id = Guid.NewGuid().ToString(),
            Role = "Assistant",
            Content = "",
            Timestamp = DateTime.Now,
            CssClass = "assistant"
        };
        
        messages.Add(assistantMessage);
        await AddLogEvent("Stream", "Started", "Streaming response initiated", "");
        StateHasChanged();

        try
        {
            if (hasRendered && !string.IsNullOrEmpty(runtimeId))
            {
                await ChatService.StreamMessageAsync(runtimeId, message, DotNetObjectReference.Create(this));
            }
        }
        catch (Exception ex)
        {
            assistantMessage.Content = $"Stream error: {ex.Message}";
            await AddLogEvent("Stream", "Error", ex.Message, "");
            StateHasChanged();
        }
    }

    private async Task AddUserMessage(string content)
    {
        var message = new Models.ChatMessage
        {
            Id = Guid.NewGuid().ToString(),
            Role = "You",
            Content = content,
            Timestamp = DateTime.Now,
            CssClass = "user"
        };

        // Check if user message contains markdown
        if (MarkdownHelper.ContainsMarkdown(content))
        {
            message.IsMarkdown = true;
        }

        messages.Add(message);
        StateHasChanged();
        
        if (hasRendered)
        {
            await ChatService.ScrollToBottomAsync();
        }
    }

    private async Task AddSystemMessage(string content)
    {
        messages.Add(new Models.ChatMessage
        {
            Id = Guid.NewGuid().ToString(),
            Role = "System",
            Content = content,
            Timestamp = DateTime.Now,
            CssClass = "system"
        });
        
        StateHasChanged();
        if (hasRendered)
        {
            await ChatService.ScrollToBottomAsync();
        }
    }
    #endregion

    #region Panel Management
    private async Task ToggleLogPanel()
    {
        showLogPanel = !showLogPanel;
        StateHasChanged();
        
        if (hasRendered)
        {
            await Task.Delay(300); // Wait for CSS transition
            await ChatService.ScrollToBottomAsync();
            await ChatService.ScrollLogToBottomAsync();
        }
    }

    private async Task ClearChat()
    {
        messages.Clear();
        StateHasChanged();
    }

    private async Task ClearLogs()
    {
        logEvents.Clear();
        StateHasChanged();
    }
    #endregion

    #region Logging
    private async Task AddLogEvent(string type, string subType, string details, string data)
    {
        logEvents.Add(new Models.LogEvent
        {
            Id = Guid.NewGuid().ToString(),
            Type = $"{type} - {subType}",
            Details = details,
            Data = data,
            Timestamp = DateTime.Now,
            CssClass = GetLogEventCssClass(type.ToLower())
        });
        
        StateHasChanged();
        if (hasRendered && showLogPanel)
        {
            await ChatService.ScrollLogToBottomAsync();
        }
    }

    private string GetLogEventCssClass(string type)
    {
        return type.ToLower() switch
        {
            "tool" => "log-tool",
            "reasoning" => "log-reasoning", 
            "stream" => "log-stream",
            "error" => "log-error",
            "runtime" => "log-runtime",
            "message" => "log-message",
            _ => "log-default"
        };
    }
    #endregion

    #region Streaming Event Handlers
    [JSInvokable]
    public async Task OnStreamEvent(string eventType, string data)
    {
        await InvokeAsync(() =>
        {
            try
            {
                var lastMessage = messages.LastOrDefault(m => m.CssClass == "assistant");
                if (lastMessage == null) return;

                switch (eventType)
                {
                    case "output_text_delta":
                        var deltaData = JsonSerializer.Deserialize<Models.TextDeltaEvent>(data, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                        if (deltaData?.Text != null)
                        {
                            lastMessage.Content += deltaData.Text;
                        }
                        break;

                    case "tool_invoked":
                        var toolEvent = JsonSerializer.Deserialize<Models.ToolEvent>(data, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                        if (toolEvent != null)
                        {
                            _ = AddLogEvent("Tool", "Invoked", $"Tool: {toolEvent.ToolName}", JsonSerializer.Serialize(toolEvent, new JsonSerializerOptions { WriteIndented = true }));
                        }
                        break;

                    case "reasoning_part_added":
                        var reasoningEvent = JsonSerializer.Deserialize<Models.ReasoningEvent>(data, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                        if (reasoningEvent != null)
                        {
                            _ = AddLogEvent("Reasoning", "Part Added", reasoningEvent.Text ?? "Thinking...", "");
                        }
                        break;

                    case "stream_complete":
                        // Mark as markdown if it contains markdown syntax
                        if (MarkdownHelper.ContainsMarkdown(lastMessage.Content))
                        {
                            lastMessage.IsMarkdown = true;
                        }
                        _ = AddLogEvent("Stream", "Complete", "Response streaming completed", "");
                        break;

                    default:
                        // Log all other event types
                        _ = AddLogEvent("Event", eventType.Replace("_", " ").ToTitleCase(), "Event received", data);
                        break;
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing stream event: {ex.Message}");
                _ = AddLogEvent("Error", "Event Processing", ex.Message, eventType + ": " + data);
            }
        });
    }

    [JSInvokable]
    public async Task OnStreamError(string error)
    {
        await InvokeAsync(() =>
        {
            var lastMessage = messages.LastOrDefault(m => m.CssClass == "assistant");
            if (lastMessage != null)
            {
                lastMessage.Content += $"\n\n? Stream error: {error}";
                StateHasChanged();
            }
        });
    }

    [JSInvokable]
    public async Task OnStreamComplete()
    {
        await InvokeAsync(() =>
        {
            isConnecting = false;
            _ = AddLogEvent("Stream", "Session Complete", "Streaming session finished", "");
            StateHasChanged();
        });
    }
    #endregion

    public void Dispose()
    {
        ChatService?.Dispose();
    }
}