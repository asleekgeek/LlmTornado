@page "/"
@page "/chat"
@using Microsoft.AspNetCore.Components.Web
@using System.Text.Json
@using LlmTornado.Chat.Web.Helpers
@inject IJSRuntime JSRuntime
@inject IConfiguration Configuration
@implements IDisposable
@rendermode InteractiveServer

<PageTitle>LlmTornado Chat</PageTitle>

<link href="css/chat.css" rel="stylesheet" />

<div class="chat-container">
    <div class="chat-header">
        <h2>üå™Ô∏è LlmTornado Chat</h2>
        <div class="chat-controls">
            <button class="btn btn-outline-secondary" @onclick="ClearChat" disabled="@isConnecting">
                üóëÔ∏è Clear
            </button>
            <button class="btn @(isConnected ? "btn-success" : "btn-secondary")" disabled>
                @(isConnected ? "üü¢ Connected" : "üî¥ Disconnected")
            </button>
        </div>
    </div>

    <div class="chat-messages" id="chat-messages">
        @foreach (var message in messages)
        {
            <div class="message @message.CssClass" key="@message.Id">
                <div class="message-header">
                    <span class="message-role">@message.Role</span>
                    <span class="message-timestamp">@message.Timestamp.ToString("HH:mm:ss")</span>
                </div>
                <div class="message-content">
                    @if (message.IsMarkdown)
                    {
                        @((MarkupString)MarkdownHelper.ToHtml(message.Content))
                    }
                    else if (message.IsHtml)
                    {
                        @((MarkupString)message.Content)
                    }
                    else
                    {
                        <pre style="white-space: pre-wrap; font-family: inherit; margin: 0;">@message.Content</pre>
                    }
                </div>
                @if (message.Events.Any())
                {
                    <div class="message-events">
                        @foreach (var evt in message.Events)
                        {
                            <div class="event-item @evt.CssClass">
                                <span class="event-type">@evt.Type</span>
                                <span class="event-content">@evt.Description</span>
                            </div>
                        }
                    </div>
                }
            </div>
        }

        @if (isConnecting)
        {
            <div class="message assistant">
                <div class="message-header">
                    <span class="message-role">Assistant</span>
                    <span class="message-timestamp">@DateTime.Now.ToString("HH:mm:ss")</span>
                </div>
                <div class="message-content">
                    <div class="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                    <span class="thinking-text">Thinking...</span>
                </div>
            </div>
        }
    </div>

    <div class="chat-input-container">
        <div class="input-group">
            <textarea @bind="currentMessage" 
                      @onkeydown="HandleKeyDown" 
                      class="form-control chat-input" 
                      placeholder="Type your message here... (Markdown supported)" 
                      disabled="@isConnecting"
                      rows="1"
                      style="resize: vertical; min-height: 38px;"></textarea>
            <button @onclick="SendMessage" 
                    class="btn btn-primary" 
                    disabled="@(isConnecting || string.IsNullOrWhiteSpace(currentMessage))">
                @if (isConnecting)
                {
                    <span class="spinner-border spinner-border-sm me-2"></span>
                }
                Send
            </button>
        </div>
    </div>
</div>

@code {
    private List<ChatMessage> messages = new();
    private string currentMessage = "";
    private bool isConnecting = false;
    private bool isConnected = false;
    private string? runtimeId;
    private HttpClient? httpClient;
    private string apiBaseUrl = "";
    private bool hasRendered = false;

    protected override async Task OnInitializedAsync()
    {
        apiBaseUrl = Configuration["ChatApi:BaseUrl"] ?? "https://localhost:7242";
        httpClient = new HttpClient();
        httpClient.BaseAddress = new Uri(apiBaseUrl);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            hasRendered = true;
            await CreateChatRuntime();
        }
    }

    private async Task CreateChatRuntime()
    {
        try
        {
            var request = new
            {
                configurationType = "simple",
                agentName = "LlmTornadoChat",
                instructions = "You are a helpful AI assistant. Be concise but informative. You can use markdown formatting in your responses.",
                enableStreaming = true
            };

            var response = await httpClient!.PostAsJsonAsync("api/chatruntime/create", request);
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadAsStringAsync();
                var createResponse = JsonSerializer.Deserialize<CreateRuntimeResponse>(result, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                runtimeId = createResponse?.RuntimeId;
                isConnected = !string.IsNullOrEmpty(runtimeId);

                if (isConnected)
                {
                    await AddSystemMessage($"Connected to runtime: {runtimeId}");
                }
            }
        }
        catch (Exception ex)
        {
            await AddSystemMessage($"Failed to connect: {ex.Message}");
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || isConnecting || string.IsNullOrEmpty(runtimeId))
            return;

        var userMessage = currentMessage;
        currentMessage = "";
        
        await AddUserMessage(userMessage);
        
        isConnecting = true;
        StateHasChanged();

        try
        {
            await StreamMessage(userMessage);
        }
        catch (Exception ex)
        {
            await AddSystemMessage($"Error: {ex.Message}");
        }
        finally
        {
            isConnecting = false;
            StateHasChanged();
        }
    }

    private async Task StreamMessage(string message)
    {
        var assistantMessage = new ChatMessage
        {
            Id = Guid.NewGuid().ToString(),
            Role = "Assistant",
            Content = "",
            Timestamp = DateTime.Now,
            CssClass = "assistant"
        };
        
        messages.Add(assistantMessage);
        StateHasChanged();

        try
        {
            var request = new { content = message };
            
            // Use EventSource for SSE streaming
            if (hasRendered)
            {
                await JSRuntime.InvokeVoidAsync("startEventSource", 
                    $"{apiBaseUrl}/api/chatruntime/{runtimeId}/stream",
                    JsonSerializer.Serialize(request),
                    DotNetObjectReference.Create(this));
            }
        }
        catch (Exception ex)
        {
            assistantMessage.Content = $"Stream error: {ex.Message}";
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task OnStreamEvent(string eventType, string data)
    {
        await InvokeAsync(() =>
        {
            try
            {
                var lastMessage = messages.LastOrDefault(m => m.CssClass == "assistant");
                if (lastMessage == null) return;

                switch (eventType)
                {
                    case "output_text_delta":
                        var deltaData = JsonSerializer.Deserialize<TextDeltaEvent>(data, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                        if (deltaData?.Text != null)
                        {
                            lastMessage.Content += deltaData.Text;
                        }
                        break;

                    case "tool_invoked":
                        var toolEvent = JsonSerializer.Deserialize<ToolEvent>(data, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                        if (toolEvent != null)
                        {
                            lastMessage.Events.Add(new ChatEvent
                            {
                                Type = "Tool Call",
                                Description = $"Calling {toolEvent.ToolName}",
                                CssClass = "tool-call"
                            });
                        }
                        break;

                    case "reasoning_part_added":
                        var reasoningEvent = JsonSerializer.Deserialize<ReasoningEvent>(data, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                        if (reasoningEvent != null)
                        {
                            lastMessage.Events.Add(new ChatEvent
                            {
                                Type = "Reasoning",
                                Description = reasoningEvent.Text ?? "Thinking...",
                                CssClass = "reasoning"
                            });
                        }
                        break;

                    case "stream_complete":
                        // Mark as markdown if it contains markdown syntax
                        if (MarkdownHelper.ContainsMarkdown(lastMessage.Content))
                        {
                            lastMessage.IsMarkdown = true;
                        }
                        break;

                    default:
                        // Handle other event types
                        lastMessage.Events.Add(new ChatEvent
                        {
                            Type = eventType.Replace("_", " ").ToTitleCase(),
                            Description = data,
                            CssClass = "progress"
                        });
                        break;
                }

                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing stream event: {ex.Message}");
            }
        });
    }

    [JSInvokable]
    public async Task OnStreamError(string error)
    {
        await InvokeAsync(() =>
        {
            var lastMessage = messages.LastOrDefault(m => m.CssClass == "assistant");
            if (lastMessage != null)
            {
                lastMessage.Content += $"\n\n‚ùå Stream error: {error}";
                StateHasChanged();
            }
        });
    }

    [JSInvokable]
    public async Task OnStreamComplete()
    {
        await InvokeAsync(() =>
        {
            isConnecting = false;
            StateHasChanged();
        });
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task AddUserMessage(string content)
    {
        var message = new ChatMessage
        {
            Id = Guid.NewGuid().ToString(),
            Role = "You",
            Content = content,
            Timestamp = DateTime.Now,
            CssClass = "user"
        };

        // Check if user message contains markdown
        if (MarkdownHelper.ContainsMarkdown(content))
        {
            message.IsMarkdown = true;
        }

        messages.Add(message);
        
        StateHasChanged();
        if (hasRendered)
        {
            await ScrollToBottom();
        }
    }

    private async Task AddSystemMessage(string content)
    {
        messages.Add(new ChatMessage
        {
            Id = Guid.NewGuid().ToString(),
            Role = "System",
            Content = content,
            Timestamp = DateTime.Now,
            CssClass = "system"
        });
        
        StateHasChanged();
        if (hasRendered)
        {
            await ScrollToBottom();
        }
    }

    private async Task ClearChat()
    {
        messages.Clear();
        StateHasChanged();
    }

    private async Task ScrollToBottom()
    {
        if (hasRendered)
        {
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("scrollToBottom", "chat-messages");
        }
    }

    public void Dispose()
    {
        httpClient?.Dispose();
    }

    private class ChatMessage
    {
        public string Id { get; set; } = "";
        public string Role { get; set; } = "";
        public string Content { get; set; } = "";
        public DateTime Timestamp { get; set; }
        public string CssClass { get; set; } = "";
        public bool IsHtml { get; set; } = false;
        public bool IsMarkdown { get; set; } = false;
        public List<ChatEvent> Events { get; set; } = new();
    }

    private class ChatEvent
    {
        public string Type { get; set; } = "";
        public string Description { get; set; } = "";
        public string CssClass { get; set; } = "";
    }

    private class CreateRuntimeResponse
    {
        public string? RuntimeId { get; set; }
        public string? Status { get; set; }
    }

    private class TextDeltaEvent
    {
        public string? Text { get; set; }
    }

    private class ToolEvent
    {
        public string? ToolName { get; set; }
        public string? Parameters { get; set; }
    }

    private class ReasoningEvent
    {
        public string? Text { get; set; }
    }
}}